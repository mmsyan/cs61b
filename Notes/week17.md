# Lecture 17: Introduction to Asymptotic Analysis

## Phase1 什么是有效编程
&emsp;&emsp;我们可以从两个不同的角度思考编写有效程序的过程：

- 编程成本：你花了多久时间去编写程序（十分钟，一小时……）？你的程序是否容易阅读和修改？你的程序是否易于修改？
- 执行成本：时间复杂度（你的程序需要多长时间完成执行？）以及空间复杂度（你的程序运行时消耗多少内存？）

&emsp;&emsp;编程成本与编程习惯、编程工具、编程思维密切相关。而本部分内容关注执行成本。我们首先来研究所选用算法对执行成本的影响。现在你的任务是判断有序数组是否包含重复项。愚蠢的算法是比较每一对数组元素，所有的A[i]和A[j]，然后得出结论。更高明的算法是明白，有序数组如果包含重复项，那么它们一定相邻。因此我们只需要比较相邻项即可。从直觉上来看，高明的算法当然更好，但是究竟好在哪里？我们如何实际量化或确定程序的效率？本章将提供规范的技术和工具来比较各种算法的效率！

<br>
<br>
##  Phase2 运行时间表征1：计时
&emsp;&emsp;为了研究这些技术，我们将表征下面两个函数的运行时间。这两个函数就是我们上面所讨论的寻找重复项的函数。记住，我们的量化表征必须满足两个要求：简单并且在数学上是严谨的；能够清楚地证明dup2优于dup1。

&emsp;&emsp;表征技术1是使用客户端程序以秒为单位测量执行时间（即实际查看我们的程序在物理秒内运行的速度）。包括：

- 使用物理秒表
- 或者，Unix 有一个time测量执行时间的内置命令。
- 或者，普林斯顿标准库有一个stopwatch类

&emsp;&emsp;可以观察到，随着输入大小的增加，我们可以看到dup1需要更长的时间才能完成，而dup2以相对大致相同的速度完成。

&emsp;&emsp;这种表征方式有着明显地优点与缺点。

- 优点：非常容易测量（只需运行秒表）。结果很清楚（看看完成所需的实际时间长度）。
- 缺点：测试可能花费很多时间。程序耗时也可能因运行程序的机器类型、编译器、输入数据等而异。

&emsp;&emsp;这种方法并不通用，我们尝试使用其余方法来量化执行时间。

<br>
<br>
##  Phase3 运行时间表征2：数操作

&emsp;&emsp;现在我们尝试构建一个模型，帮助我们衡量算法所需的运行时间。我们可以数每条指令执行了多少次。例如，给定数组大小为10000，去计算<=比较进行了多少次，自增一进行了多少次……

- 优点：只与算法本身有关，和机器、操作系统、编译器没有关系；
- 缺点：数操作的过程繁琐复杂；数组大小不是给定的；只能得出操作数量，不能得出耗费时间

&emsp;&emsp;假如给定数组大小为N，再去数操作呢？我们不再得到具体的数字，而是得到关于N的表达式。例如，j += 1操作进行了1--N次（从最好情况到最坏情况），而A[i] == A[j]操作进行了1--(N-1)*N/2次。这种做法告诉了我们各项操作的规模（常数大小，线性大小，平方大小，立方大小……） 
<br>
<br>
##  Phase4 运行时间表征3：渐进性
&emsp;&emsp;在多数时候，评价算法性能是考虑它的渐进性，即N很大时的场景。例如，渐进性为线性的算法，就优越于渐进性是平方的算法。因此在数操作方法的基础上，抽象出渐进性的概念，可以在数学上严谨的评估算法的性能。

&emsp;&emsp;然而，基于数操作而获得渐进性的方法过于复杂，回忆我们做了哪些事情：

- 计算了所有指令的调用次数
- 对于每一条指令，都考虑了最好情况和最坏情况

&emsp;&emsp;这样的过程繁琐复杂，我们有必要进行简化。

- 第一种简化是只考虑最坏情况，不再计算最好情况时的性能。在绝大多数情况下，我们只需要考虑最坏的情况。当然，有些算法以"典型情况"著称，但通常我们可以只考虑最坏情况。
- 第二种简化是只考虑典型的指令。有些初始化指令只进行一次，明显不是用于衡量算法性能的标准。我们选取的应当是阶数最大且易于计算的指令。
- 第三种简化是省略低阶N。对于操作次数为N*N+N的指令来说，N平方是高阶，N是低阶，因此可以忽略N。这是因为在N足够大的时候，平方向远大于一次项。
- 第四种简化是省略常数项系数。同第三种简化，常数项系数与N的差距是在过大，应当忽略。
<br>
<br>
##  Phase5 Big Theta

&emsp;&emsp; Big Theta是一种数学符号，用来表示算法渐进性。